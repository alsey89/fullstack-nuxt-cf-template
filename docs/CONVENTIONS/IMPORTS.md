# Import Aliases & Auto-Import Conventions

This project uses TypeScript path aliases to simplify imports and avoid deeply nested relative paths. Nuxt 4 also automatically imports components, composables, utilities, and stores.

## Import Alias Configuration

| Alias              | Points To      | Use In                                            | Example                                                     |
| ------------------ | -------------- | ------------------------------------------------- | ----------------------------------------------------------- |
| `~` or `@`         | `app/`         | Frontend code (components, pages, composables)    | `import Button from '@/components/ui/Button.vue'`           |
| `#server`          | `server/`      | Backend code (services, repositories, middleware) | `import { createRBACService } from '#server/services/rbac'` |
| `~~` or `@@`       | Project root   | Cross-boundary imports (rare)                     | `import type { ApiResponse } from '~~/server/types/api'`    |
| `#app`, `#imports` | Nuxt internals | Framework auto-imports                            | `import { useAsyncData } from '#app'`                       |

## Import Conventions

### Frontend (app/) Code

Use `~` or `@` for all imports within the frontend:

```typescript
// ✅ GOOD: Use @ alias
import { Button } from "@/components/ui/button";
import { useAuth } from "@/composables/useAuth";
import { formatDate } from "@/lib/utils";

// ❌ BAD: Relative imports
import { Button } from "../../../components/ui/button";
import { useAuth } from "../../composables/useAuth";
```

### Backend (server/) Code

Use `#server` for all imports within the backend:

```typescript
// ✅ GOOD: Use #server alias
import { createIdentityService } from "#server/services/identity";
import { ValidationError } from "#server/error/errors";
import { createSuccessResponse } from "#server/lib/response";
import type { PermissionCode } from "#server/database/schema/identity";

// ❌ BAD: Relative imports
import { createIdentityService } from "../../../services/identity";
import { ValidationError } from "../../error/errors";
```

### Cross-Boundary Imports

Use `~~` (project root) when importing across app/server boundaries:

```typescript
// Frontend importing shared server types
import type { ApiResponse } from "~~/server/types/api";
import { ERROR_CODES } from "~~/server/error/codes";

// Server importing from project root (rare)
import { someUtil } from "~~/utils/shared";
```

## Rules & Best Practices

1. **Never use `../` beyond one level**: If you need `../../` or more, use an alias instead
2. **Be consistent with aliases**:
   - Frontend: Always use `@` or `~`
   - Backend: Always use `#server`
   - Cross-boundary: Use `~~`
3. **Prefer aliases over relative imports**: Even for single-level imports, aliases are clearer
4. **Type imports**: Use `import type` for TypeScript types when possible to optimize bundling

## Configuration Files

Aliases are configured in:

- **nuxt.config.ts**: Main alias configuration (`alias` option)
- **tsconfig.app.json**: Frontend TypeScript paths (auto-generated by Nuxt)
- **tsconfig.server.json**: Backend TypeScript paths (auto-generated by Nuxt)
- **app/components.json**: shadcn-vue component aliases (separate from project aliases)

## VS Code Integration

VS Code automatically recognizes these aliases for:

- IntelliSense auto-completion
- Go to Definition (Cmd/Ctrl + Click)
- Auto-imports

If aliases aren't working in your IDE:

1. Restart the TypeScript server: `Cmd/Ctrl + Shift + P` → "TypeScript: Restart TS Server"
2. Restart the dev server: `npm run dev`
3. Check that `.nuxt/tsconfig.*.json` files exist

## Examples by File Type

### Service Files

```typescript
// server/services/identity.ts
import { UserRepository } from "#server/repositories/identity";
import { Hash } from "@adonisjs/hash";
import type { NewUser } from "#server/database/schema/identity";
```

### API Routes

```typescript
// server/api/v1/auth/signin.post.ts
import { createIdentityService } from "#server/services/identity";
import { createSuccessResponse } from "#server/lib/response";
import { ValidationError } from "#server/error/errors";
import { signinSchema } from "#shared/validators/auth";
```

### Repository Files

```typescript
// server/repositories/identity.ts
import { BaseRepository } from "#server/repositories/base";
import * as schema from "#server/database/schema";
import type { User, NewUser } from "#server/database/schema/identity";
```

### Frontend Components

```typescript
// app/components/auth/LoginForm.vue
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { useAuth } from "@/composables/useAuth";
import type { ApiResponse } from "~~/server/types/api";
```

---

## Auto-Import Conventions

Nuxt 4 automatically imports components, composables, utilities, and stores based on directory structure and naming conventions. Understanding these patterns is crucial for maintaining a clean and consistent codebase.

### Auto-Import Directories

| Directory          | Auto-imports      | Naming Convention                  | Case Requirement         | Import Needed?        |
| ------------------ | ----------------- | ---------------------------------- | ------------------------ | --------------------- |
| `app/components/`  | Yes               | Folder/File.vue → `<FolderFile />` | PascalCase folders/files | ❌ No (auto-imported) |
| `app/composables/` | Yes               | `use` prefix required              | camelCase                | ❌ No (auto-imported) |
| `app/utils/`       | Yes               | No prefix required                 | Any case                 | ❌ No (auto-imported) |
| `app/stores/`      | Yes               | `use[Name]Store` pattern           | camelCase                | ❌ No (auto-imported) |
| `server/utils/`    | Yes (server-only) | No prefix required                 | Any case                 | ❌ No (auto-imported) |
| `app/plugins/`     | Auto-registered   | `defineNuxtPlugin()`               | Any case                 | N/A (auto-registered) |
| `app/middleware/`  | Auto-registered   | Route-based                        | kebab-case               | N/A (auto-registered) |

**Note:** All components including UI library components (shadcn-vue in `app/components/ui/`) are auto-imported by Nuxt.

## Component Auto-Import Rules

Components are auto-imported based on their **folder path**, using folder-based naming:

```
File path: app/components/Folder/File.vue
Component name in template: <FolderFile />
```

**Examples from this codebase:**

```
app/components/App/Sidebar.vue        → <AppSidebar />
app/components/Tours/SceneManager.vue → <ToursSceneManager />
app/components/Billing/TierBadge.vue  → <BillingTierBadge />
```

**Component Naming Rules:**

```vue
<!-- ✅ GOOD: Capitalized folder, PascalCase file -->
<script setup>
// No imports needed - auto-imported!
const userStore = useUserStore();
const route = useRoute();
</script>

<template>
  <AppSidebar />
  <ToursSceneManager />
  <BillingTierBadge />
</template>

<!-- ❌ BAD: Lowercase folder names -->
app/components/app/sidebar.vue
<!-- Won't work correctly -->

<!-- ❌ BAD: Deeply nested (3+ levels) -->
app/components/Tours/Editor/Scene/Card.vue
<!-- Too nested -->

<!-- ❌ BAD: Using index.vue -->
app/components/App/index.vue
<!-- Nuxt won't auto-import correctly -->

<!-- ✅ GOOD: UI library components also auto-imported -->
<script setup>
// No imports needed - UI components are auto-imported
</script>

<template>
  <Button>Click</Button>
  <!-- Auto-imported -->
  <Card>Content</Card>
  <!-- Auto-imported -->
</template>
```

**Best Practices:**

- ✅ Keep folders 2 levels max: `Category/ComponentName.vue`
- ✅ Capitalize folder names for components (App, Tours, Billing)
- ✅ Use PascalCase for file names (Sidebar.vue, SceneManager.vue)
- ✅ Only create components when reused 2+ times
- ❌ Don't import custom components explicitly (auto-imported)
- ❌ Don't use lowercase folder names for components

## Composable Auto-Import Rules

Composables MUST follow the `use` prefix convention to be auto-imported:

```typescript
// ✅ GOOD: Proper composable structure
// File: app/composables/useMarzipano.ts
export function useMarzipano() {
  const viewer = ref(null);
  const loadViewer = () => {
    /* ... */
  };
  return { viewer, loadViewer };
}

// Usage (no import needed):
const { viewer, loadViewer } = useMarzipano();

// ❌ BAD: Missing 'use' prefix
// File: app/composables/marzipano.ts
export function marzipano() {
  /* ... */
} // Won't auto-import

// ❌ BAD: Wrong export pattern
export default function () {
  /* ... */
} // Won't auto-import
```

**Composables in this codebase:**

```typescript
useErrorHandler(); // app/composables/useErrorHandler.ts
useExtendedFetch(); // app/composables/useExtendedFetch.ts
useMarzipano(); // app/composables/useMarzipano.ts
useRetry(); // app/composables/useRetry.ts
useShowToast(); // app/composables/useShowToast.js
```

**Best Practices:**

- ✅ Always use `use` prefix
- ✅ Export named function matching filename (without extension)
- ✅ Use composition API patterns (ref, computed, reactive)
- ❌ Don't create composables that are just single functions (use utils instead)
- ❌ Don't wrap stores in composables (use stores directly)

## Store Auto-Import Rules

Pinia stores MUST follow the `use[Name]Store` convention:

```typescript
// ✅ GOOD: Proper store structure
// File: app/stores/userStore.ts
import { defineStore } from 'pinia'
import { ref, computed } from 'vue'

export const useUserStore = defineStore('user', () => {
  // State
  const user = ref(null)

  // Getters
  const isAuthenticated = computed(() => user.value !== null)

  // Actions
  async function fetchUser() { /* ... */ }

  return { user, isAuthenticated, fetchUser }
})

// Usage (no import needed):
const userStore = useUserStore()

// ❌ BAD: Wrong naming pattern
export const userStore = defineStore(...)  // Missing 'use' prefix
export const useUser = defineStore(...)    // Missing 'Store' suffix
```

**Stores in this codebase:**

```typescript
useBillingStore(); // app/stores/billingStore.ts
useProjectStore(); // app/stores/projectStore.ts
useUserStore(); // app/stores/userStore.ts
```

**Best Practices:**

- ✅ Use composition API: `defineStore('name', () => { ... })`
- ✅ ALL API calls use `extendedFetch` (automatic error handling)
- ✅ Return state, getters, and actions
- ✅ Include reset() function for signout
- ❌ Don't use options API for stores
- ❌ Don't make direct API calls in pages (use stores)

## Utils Auto-Import Rules

Utils have no naming requirements and are auto-imported:

```typescript
// ✅ GOOD: Simple util function
// File: app/utils/stringutils.js
export function convertToInitials(str) {
  return str
    .split(" ")
    .map((word) => word[0])
    .join("");
}

// Usage (no import needed):
const initials = convertToInitials("John Doe");

// ❌ BAD: Default export
export default function convertToInitials(str) {
  /* ... */
} // Won't auto-import
```

**Server Utils** (server-side only):

```typescript
// File: server/utils/pagination.ts
export function parsePaginationParams(query: any) {
  // Utility logic
}

// Usage in API routes (no import needed):
const { page, perPage } = parsePaginationParams(query);
```

**Best Practices:**

- ✅ Use for simple, reusable functions
- ✅ Export named functions
- ✅ Keep utils pure (no side effects)
- ❌ Don't use for complex stateful logic (use composables)
- ❌ Don't export default

## Plugin Auto-Registration

Plugins are automatically registered based on file naming:

```typescript
// File: app/plugins/theme.client.ts  (client-side only)
export default defineNuxtPlugin(() => {
  // Plugin logic runs automatically
});

// File: app/plugins/analytics.server.ts  (server-side only)
// File: app/plugins/myPlugin.ts  (both sides)
```

**File naming conventions:**

- `.client.ts` - Client-side only
- `.server.ts` - Server-side only
- `.ts` - Both client and server

## When Imports ARE Required

Despite auto-imports, you still need explicit imports for:

1. **Type-only Imports** (optimization):

```typescript
import type { User } from "@/stores/userStore";
import type { ApiResponse } from "~~/server/types/api";
```

2. **Third-party Libraries**:

```typescript
import { format } from "date-fns";
import { z } from "zod";
```

3. **Shared Validators** (cross-boundary):

```typescript
import { signinSchema } from "#shared/validators/auth";
```

## Auto-Import Verification

Nuxt generates type definitions for all auto-imports in `.nuxt/`:

```
.nuxt/
├── components.d.ts  # Component auto-imports
├── imports.d.ts     # Composables, utils, stores
└── tsconfig.json    # TypeScript configuration
```

If auto-imports stop working:

1. Restart dev server: `npm run dev`
2. Check `.nuxt/` folder exists
3. Restart TypeScript server in IDE
4. Verify file naming matches conventions

## Complete Auto-Import Example

```vue
<script setup lang="ts">
// ============================================
// AUTO-IMPORTED (no import statements needed)
// ============================================

// Nuxt composables
const route = useRoute();
const router = useRouter();
const { t } = useI18n();

// Custom composables
const { viewer } = useMarzipano();
const { retry } = useRetry();

// Stores
const userStore = useUserStore();
const projectStore = useProjectStore();

// Utils
const initials = convertToInitials("John Doe");

// ============================================
// EXPLICIT IMPORTS (required)
// ============================================

// Type imports (optimization)
import type { Project } from "@/stores/projectStore";
import type { ApiResponse } from "~~/server/types/api";

// Third-party libraries
import { z } from "zod";

// Shared validators
import { createProjectSchema } from "#shared/validators/project";
</script>

<template>
  <!-- All components auto-imported -->
  <AppSidebar />
  <ToursSceneManager />
  <Button>Click me</Button>
  <Card>Content</Card>
</template>
```

---

## Related Documentation

**Quick Reference:**

- [Common Pitfalls](./COMMON_PITFALLS.md#imports--aliases) - Import-related mistakes
- [Naming Conventions](./NAMING.md) - File naming for auto-imports

**Deep Dive:**

- [Frontend Guide](../FRONTEND/README.md) - Frontend patterns (when available)
- [Conventions Overview](../CLAUDE.md) - Complete conventions
